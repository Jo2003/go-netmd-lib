package netmd

import (
	"crypto/cipher"
	"crypto/des"
	"math/rand"
)

type EKB struct {
	id        int
	depth     int
	signature []byte
	chain     []byte
	root      []byte
	iv        []byte
	contentId []byte
	kek       []byte
	dataKey   []byte
	nonce     *Nonce
}

func NewEKB() (e *EKB) {
	e = &EKB{
		id:        0x26422642,
		chain:     []byte{0x25, 0x45, 0x06, 0x4d, 0xea, 0xca, 0x14, 0xf9, 0x96, 0xbd, 0xc8, 0xa4, 0x06, 0xc2, 0x2b, 0x81, 0x49, 0xba, 0xf0, 0xdf, 0x26, 0x9d, 0xb7, 0x1d, 0x49, 0xba, 0xf0, 0xdf, 0x26, 0x9d, 0xb7, 0x1d},
		depth:     9,
		signature: []byte{0xe8, 0xef, 0x73, 0x45, 0x8d, 0x5b, 0x8b, 0xf8, 0xe8, 0xef, 0x73, 0x45, 0x8d, 0x5b, 0x8b, 0xf8, 0x38, 0x5b, 0x49, 0x36, 0x7b, 0x42, 0x0c, 0x58},
		root:      []byte{0x13, 0x37, 0x13, 0x37, 0x13, 0x37, 0x13, 0x37, 0x13, 0x37, 0x13, 0x37, 0x13, 0x37, 0x13, 0x37},
		iv:        []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
		contentId: []byte{0x01, 0x0F, 0x50, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x48, 0xA2, 0x8D, 0x3E, 0x1A, 0x3B, 0x0C, 0x44, 0xAF, 0x2f, 0xa0},
		kek:       []byte{0x14, 0xe3, 0x83, 0x4e, 0xe2, 0xd3, 0xcc, 0xa5},
		nonce:     NewNonce(),
	}
	return
}

func (ekb *EKB) CreateKey() (dataKey []byte) {
	dataKey = make([]byte, 8)
	for i := 0; i < 8; i++ {
		dataKey[i] = byte(rand.Int()) & 0xff
	}
	return
}

func (ekb *EKB) Key16to24() []byte {
	var b []byte
	b = append(b, ekb.root[:16]...)
	b = append(b, ekb.root[:8]...)
	return b
}

func (ekb *EKB) RetailMAC() ([]byte, error) {
	iv, err := DESEncrypt(ekb.nonce.Host, ekb.root[:8])
	if err != nil {
		return nil, err
	}

	des3Block, err := des.NewTripleDESCipher(ekb.Key16to24())
	if err != nil {
		return nil, err
	}
	blkMode := cipher.NewCBCEncrypter(des3Block, iv)
	session := make([]byte, len(ekb.nonce.Dev))
	blkMode.CryptBlocks(session, ekb.nonce.Dev)

	return session, nil
}
